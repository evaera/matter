"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[347],{90687:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new World.","params":[],"returns":[],"function_type":"static","source":{"line":25,"path":"lib/World.lua"}},{"name":"__iter","desc":"Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping\\nComponent to Component Instance.\\n\\n**Usage:**\\n\\n```lua\\nfor entityId, entityData in world do\\n\\tprint(entityId, entityData[Components.Example])\\nend\\n```","params":[],"returns":[{"desc":"","lua_type":"number"},{"desc":"","lua_type":"{[Component]: ComponentInstance}"}],"function_type":"method","source":{"line":118,"path":"lib/World.lua"}},{"name":"spawn","desc":"Spawns a new entity in the world with the given components.","params":[{"name":"...","desc":"The component values to spawn the entity with.","lua_type":"ComponentInstance"}],"returns":[{"desc":"The new entity ID.","lua_type":"number"}],"function_type":"method","source":{"line":128,"path":"lib/World.lua"}},{"name":"spawnAt","desc":"Spawns a new entity in the world with a specific entity ID and given components.\\n\\nThe next ID generated from [World:spawn] will be increased as needed to never collide with a manually specified ID.","params":[{"name":"id","desc":"The entity ID to spawn with","lua_type":"number"},{"name":"...","desc":"The component values to spawn the entity with.","lua_type":"ComponentInstance"}],"returns":[{"desc":"The same entity ID that was passed in","lua_type":"number"}],"function_type":"method","source":{"line":141,"path":"lib/World.lua"}},{"name":"replace","desc":"Replaces a given entity by ID with an entirely new set of components.\\nEquivalent to removing all components from an entity, and then adding these ones.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The component values to spawn the entity with.","lua_type":"ComponentInstance"}],"returns":[],"function_type":"method","source":{"line":259,"path":"lib/World.lua"}},{"name":"despawn","desc":"Despawns a given entity by ID, removing it and all its components from the world entirely.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":301,"path":"lib/World.lua"}},{"name":"clear","desc":"Removes all entities from the world.\\n\\n:::caution\\nRemoving entities in this way is not reported by `queryChanged`.\\n:::","params":[],"returns":[],"function_type":"method","source":{"line":321,"path":"lib/World.lua"}},{"name":"contains","desc":"Checks if the given entity ID is currently spawned in this world.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"}],"returns":[{"desc":"`true` if the entity exists","lua_type":"bool"}],"function_type":"method","source":{"line":337,"path":"lib/World.lua"}},{"name":"get","desc":"Gets a specific component (or set of components) from a specific entity in this world.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The components to fetch","lua_type":"Component"}],"returns":[{"desc":"Returns the component values in the same order they were passed in","lua_type":"..."}],"function_type":"method","source":{"line":348,"path":"lib/World.lua"}},{"name":"query","desc":"Performs a query against the entities in this World. Returns a [QueryResult](/api/QueryResult), which iterates over\\nthe results of the query.\\n\\nOrder of iteration is not guaranteed.\\n\\n```lua\\nfor id, enemy, charge, model in world:query(Enemy, Charge, Model) do\\n\\t-- Do something\\nend\\n\\nfor id in world:query(Target):without(Model) do\\n\\t-- Again, with feeling\\nend\\n```","params":[{"name":"...","desc":"The component types to query. Only entities with *all* of these components will be returned.","lua_type":"Component"}],"returns":[{"desc":"See [QueryResult](/api/QueryResult) docs.","lua_type":"QueryResult"}],"function_type":"method","source":{"line":552,"path":"lib/World.lua"}},{"name":"queryChanged","desc":":::info Topologically-aware function\\nThis function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).\\n:::\\n\\nQueries for components that have changed **since the last time your system ran `queryChanged`**.\\n\\nOnly one changed record is returned per entity, even if the same entity changed multiple times. The order\\nin which changed records are returned is not guaranteed to be the order that the changes occurred in.\\n\\nIt should be noted that `queryChanged` does not have the same iterator invalidation concerns as `World:query`.\\n\\n:::tip\\nThe first time your system runs (i.e., on the first frame), all existing entities in the world that match your query\\nare returned as \\"new\\" change records.\\n:::\\n\\n:::info\\nCalling this function from your system creates storage internally for your system. Then, changes meeting your\\ncriteria are pushed into your storage. Calling `queryChanged` again each frame drains this storage.\\n\\nIf your system isn\'t called every frame, the storage will continually fill up and does not empty unless you drain\\nit.\\n\\nIf you stop calling `queryChanged` in your system, changes will stop being tracked.\\n:::\\n\\n### Returns\\n`queryChanged` returns an iterator function, so you call it in a for loop just like `World:query`.\\n\\nThe iterator returns the entity ID, followed by a [`ChangeRecord`](#ChangeRecord).\\n\\nThe `ChangeRecord` type is a table that contains two fields, `new` and `old`, respectively containing the new\\ncomponent instance, and the old component instance. `new` and `old` will never be the same value.\\n\\n`new` will be nil if the component was removed (or the entity was despawned), and `old` will be nil if the\\ncomponent was just added.\\n\\nThe `old` field will be the value of the component the last time this system observed it, not\\nnecessarily the value it changed from most recently.\\n\\nThe `ChangeRecord` table is potentially shared with multiple systems tracking changes for this component, so it\\ncannot be modified.\\n\\n```lua\\nfor id, record in world:queryChanged(Model) do\\n\\tif record.new == nil then\\n\\t\\t-- Model was removed\\n\\n\\t\\tif enemy.type == \\"this is a made up example\\" then\\n\\t\\t\\tworld:remove(id, Enemy)\\n\\t\\tend\\n\\tend\\nend\\n```","params":[{"name":"componentToTrack","desc":"The component you want to listen to changes for.","lua_type":"Component"},{"name":"...","desc":"","lua_type":"nil"}],"returns":[{"desc":"Iterator of entity ID and change record","lua_type":"() -> (id, ChangeRecord)"}],"function_type":"method","source":{"line":730,"path":"lib/World.lua"}},{"name":"insert","desc":"Inserts a component (or set of components) into an existing entity.\\n\\nIf another instance of a given component already exists on this entity, it is replaced.\\n\\n```lua\\nworld:insert(\\n\\tentityId,\\n\\tComponentA({\\n\\t\\tfoo = \\"bar\\"\\n\\t}),\\n\\tComponentB({\\n\\t\\tbaz = \\"qux\\"\\n\\t})\\n)\\n```","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The component values to insert","lua_type":"ComponentInstance"}],"returns":[],"function_type":"method","source":{"line":817,"path":"lib/World.lua"}},{"name":"remove","desc":"Removes a component (or set of components) from an existing entity.\\n\\n```lua\\nlocal removedA, removedB = world:remove(entityId, ComponentA, ComponentB)\\n```","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The components to remove","lua_type":"Component"}],"returns":[{"desc":"Returns the component instance values that were removed in the order they were passed.","lua_type":"...ComponentInstance"}],"function_type":"method","source":{"line":864,"path":"lib/World.lua"}},{"name":"size","desc":"Returns the number of entities currently spawned in the world.","params":[],"returns":[],"function_type":"method","source":{"line":905,"path":"lib/World.lua"}},{"name":"optimizeQueries","desc":":::tip\\n[Loop] automatically calls this function on your World(s), so there is no need to call it yourself if you\'re using\\na Loop.\\n:::\\n\\nIf you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize\\nthe internal storage for queries.\\n\\nThis is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query from\\n[World:query]. While inside a query, any changes to the World are stored in a separate location from the rest of\\nthe World. Calling this function combines the separate storage back into the main storage, which speeds things up\\nagain.","params":[],"returns":[],"function_type":"method","source":{"line":923,"path":"lib/World.lua"}}],"properties":[],"types":[{"name":"ChangeRecord","desc":"","fields":[{"name":"new?","lua_type":"ComponentInstance","desc":"The new value of the component. Nil if just removed."},{"name":"old?","lua_type":"ComponentInstance","desc":"The former value of the component. Nil if just added."}],"source":{"line":670,"path":"lib/World.lua"}}],"name":"World","desc":"A World contains entities which have components.\\nThe World is queryable and can be used to get entities with a specific set of components.\\nEntities are simply ever-increasing integers.","source":{"line":19,"path":"lib/World.lua"}}')}}]);