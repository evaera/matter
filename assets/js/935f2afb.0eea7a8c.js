"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","label":"Matter","href":"/matter/docs/intro","docId":"intro"},{"type":"link","label":"Installation","href":"/matter/docs/Installation","docId":"Installation"},{"type":"link","label":"Getting Started","href":"/matter/docs/GettingStarted","docId":"GettingStarted"},{"type":"link","label":"Why ECS","href":"/matter/docs/WhyECS","docId":"WhyECS"},{"type":"category","label":"Best Practices","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Reconciliation","href":"/matter/docs/BestPractices/Reconciliation","docId":"BestPractices/Reconciliation"},{"type":"link","label":"Derived state","href":"/matter/docs/BestPractices/DerivedState","docId":"BestPractices/DerivedState"},{"type":"link","label":"State Machines","href":"/matter/docs/BestPractices/StateMachines","docId":"BestPractices/StateMachines"}]},{"type":"category","label":"Guides","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Using CollectionService tags","href":"/matter/docs/Guides/CollectionService","docId":"Guides/CollectionService"},{"type":"link","label":"Hot reloading","href":"/matter/docs/Guides/HotReloading","docId":"Guides/HotReloading"},{"type":"link","label":"Matter Debugger","href":"/matter/docs/Guides/MatterDebugger","docId":"Guides/MatterDebugger"},{"type":"link","label":"Replication","href":"/matter/docs/Guides/Replication","docId":"Guides/Replication"}]}]},"docs":{"BestPractices/DerivedState":{"id":"BestPractices/DerivedState","title":"Derived state","description":"Oftentimes, games will have state that needs to be affected by multiple, distinct gameplay systems.","sidebar":"defaultSidebar"},"BestPractices/Reconciliation":{"id":"BestPractices/Reconciliation","title":"Reconciliation","description":"The Data Model","sidebar":"defaultSidebar"},"BestPractices/StateMachines":{"id":"BestPractices/StateMachines","title":"State Machines","description":"A state machine is a general programming term that describes a system that can only be in one of a few known states, and the states it can change into are also all known and defined.","sidebar":"defaultSidebar"},"GettingStarted":{"id":"GettingStarted","title":"Getting Started","description":"Here\'s how you scaffold a project with Matter.","sidebar":"defaultSidebar"},"Guides/CollectionService":{"id":"Guides/CollectionService","title":"Using CollectionService tags","description":"As a pure ECS first and foremost, Matter provides no special functionality for CollectionService tags out of the box. However, it\'s rather simple to implement this yourself. Here\'s an example taken from the official Matter example game.","sidebar":"defaultSidebar"},"Guides/HotReloading":{"id":"Guides/HotReloading","title":"Hot reloading","description":"Hot reloading allows you to see the results of new code in your game without needing to stop and start the game. Matter supports hot reloading systems. Whenever you make a change to any of your systems, you can see the results in real time in the game.","sidebar":"defaultSidebar"},"Guides/MatterDebugger":{"id":"Guides/MatterDebugger","title":"Matter Debugger","description":"The Matter debugger allows you to view your systems and create debug UI elements right inside your systems.","sidebar":"defaultSidebar"},"Guides/Replication":{"id":"Guides/Replication","title":"Replication","description":"Replication is not built into Matter, but it\'s easy to implement yourself. This guide will give you an overview of one way to implement replication wit Matter.","sidebar":"defaultSidebar"},"Installation":{"id":"Installation","title":"Installation","description":"Wally package manager","sidebar":"defaultSidebar"},"intro":{"id":"intro","title":"Matter","description":"Matter is a modern ECS library for Roblox.","sidebar":"defaultSidebar"},"WhyECS":{"id":"WhyECS","title":"Why ECS","description":"- Behavior is declarative. Systems run every frame, and declare what the state of the world should be right now. This makes code self-healing and more resilient to game-breaking bugs than in an event-driven model where reacting to something happening only happens once.","sidebar":"defaultSidebar"}}}')}}]);