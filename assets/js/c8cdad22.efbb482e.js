"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[550],{77799:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new World.","params":[],"returns":[],"function_type":"static","source":{"line":52,"path":"lib/World.lua"}},{"name":"spawn","desc":"Spawns a new entity in the world with the given components.","params":[{"name":"...","desc":"The component values to spawn the entity with.","lua_type":"ComponentInstance"}],"returns":[{"desc":"The new entity ID.","lua_type":"number"}],"function_type":"method","source":{"line":69,"path":"lib/World.lua"}},{"name":"replace","desc":"Replaces a given entity by ID with an entirely new set of components.\\nEquivalent to removing all components from an entity, and then adding these ones.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The component values to spawn the entity with.","lua_type":"ComponentInstance"}],"returns":[{"desc":"The new entity ID.","lua_type":"number"}],"function_type":"method","source":{"line":155,"path":"lib/World.lua"}},{"name":"despawn","desc":"Despawns a given entity by ID, removing it and all its components from the world entirely.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":168,"path":"lib/World.lua"}},{"name":"clear","desc":"Removes all entities from the world.\\n\\n:::warning\\nRemoving entities in this way is not reported by `queryChanged`.\\n:::","params":[],"returns":[],"function_type":"method","source":{"line":181,"path":"lib/World.lua"}},{"name":"contains","desc":"Checks if the given entity ID is currently spawned in this world.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"}],"returns":[{"desc":"`true` if the entity exists","lua_type":"bool"}],"function_type":"method","source":{"line":193,"path":"lib/World.lua"}},{"name":"get","desc":"Gets a specific component (or set of components) from a specific entity in this world.","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The components to fetch","lua_type":"Component"}],"returns":[{"desc":"Returns the component values in the same order they were passed in","lua_type":"..."}],"function_type":"method","source":{"line":204,"path":"lib/World.lua"}},{"name":"query","desc":"Performs a query against the entities in this World. Returns a [QueryResult](/api/QueryResult), which iterates over\\nthe results of the query.\\n\\n```lua\\nfor id, enemy, charge, model in world:query(Enemy, Charge, Model) do\\n\\t-- Do something\\nend\\n\\nfor id in world:query(Target):without(Model) do\\n\\t-- Again, with feeling\\nend\\n```\\n\\n&nbsp;\\n\\n:::danger Modifying the World while iterating\\n- **Do not insert new components or spawn entities that would then match the query while iterating.** The iteration\\nbehavior is undefined if the World is changed while iterating so that additional results would be returned.\\n\\n- **Removing components during iteration may cause the iterator to return the same entity multiple times**,\\n*if* the component would still meet the requirements of the query. It is safe to remove components\\nduring iteration *if and only if* the entity would no longer meet the query requirements.\\n:::\\n\\nTo mitigate against these limitations, simply build up a queue of actions to take after iteration, and then do them\\nafter your iteration loop. **Inserting existing components** and **despawning entities** during iteration is safe,\\nhowever.","params":[{"name":"...","desc":"The component types to query. Only entities with *all* of these components will be returned.","lua_type":"Component"}],"returns":[{"desc":"See [QueryResult](/api/QueryResult) docs.","lua_type":"QueryResult"}],"function_type":"method","source":{"line":381,"path":"lib/World.lua"}},{"name":"queryChanged","desc":":::info Topologically-aware function\\nThis function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).\\n:::\\n\\nQueries for components that have changed **since the last time your system ran `queryChanged`**.\\n\\nIt should be noted that `queryChanged` does not have the same iterator invalidation limitations as `World:query`.\\n\\n:::caution\\nThe first time your system runs (i.e., on the first frame), no results are returned. Results only begin to be\\ntracked after the first time your system calls this function.\\n:::\\n\\n:::info\\nCalling this function from your system creates storage internally for your system. Then, changes meeting your\\ncriteria are pushed into your storage. Calling `queryChanged` again each frame drains this storage.\\n\\nIf you do not call `queryChanged` each frame, or your system isn\'t called every frame, the storage will continually\\nfill up and does not empty unless you drain it. It is assumed that you will call `queryChanged` unconditionally,\\nevery frame, **until the end of time**.\\n:::\\n\\n### Arguments\\n\\nThe first argument to `queryChanged` is the component for which you want to track changes.\\nFurther arguments are optional, and if passed, are an additional filter on what entities will be returned.\\n\\n:::caution\\nAdditional query arguments are checked against *at the time of iteration*, not when the change ocurred.\\nThis has the additional implication that entities that have been despawned will never be returned from\\n`queryChanged` if additional query arguments are passed, because the entity will have no components, so cannot\\npossibly pass any additional query.\\n:::\\n\\nIf no additional query arguments are passed, all changes (including despawns) will be tracked and returned.\\n\\n### Returns\\n`queryChanged` returns an iterator function, so you call it in a for loop just like `World:query`.\\n\\nThe iterator returns the entity ID, followed by a [`ChangeRecord`](#ChangeRecord), followed by the component\\ninstance values of any additional query arguments that were passed (as discussed above).\\n\\nThe ChangeRecord type is a table that contains two fields, `new` and `old`, respectively containing the new\\ncomponent instance, and the old component instance. `new` and `old` will never be the same value.\\n\\n`new` will be nil if the component was removed (or the entity was despawned), and `old` will be nil if the\\ncomponent was just added.\\n\\nThe ChangeRecord table is given to all systems tracking changes for this component, and cannot be modified.\\n\\n```lua\\nfor id, modelRecord, enemy in world:queryChanged(Model, Enemy) do\\n\\tif modelRecord.new == nil then\\n\\t\\t-- Model was removed\\n\\n\\t\\tif enemy.type == \\"this is a made up example\\" then\\n\\t\\t\\tworld:remove(id, Enemy)\\n\\t\\tend\\n\\tend\\nend\\n```\\n\\n&nbsp;\\n\\n:::info\\nIt\'s conventional to end the name you assign the record with \\"-Record\\", to make clear it is a different shape than\\na regular component instance. The ChangeValue is a table with `new` and `old` fields, but additional returns for the\\nadditional query arguments are regular component instances.\\n:::","params":[{"name":"componentToTrack","desc":"The component you want to listen to changes for.","lua_type":"Component"},{"name":"...?","desc":"Additional query components. Checked at time of iteration, not time of change.","lua_type":"Component"}],"returns":[{"desc":"Iterator of entity ID followed by the requested component values, in order","lua_type":"() -> (id, ChangeRecord, ...ComponentInstance)"}],"function_type":"method","source":{"line":519,"path":"lib/World.lua"}},{"name":"insert","desc":"Inserts a component (or set of components) into an existing entity.\\n\\nIf another instance of a given component already exists on this entity, it is replaced.\\n\\n```lua\\nworld:insert(\\n\\tentityId,\\n\\tComponentA({\\n\\t\\tfoo = \\"bar\\"\\n\\t}),\\n\\tComponentB({\\n\\t\\tbaz = \\"qux\\"\\n\\t})\\n)\\n```","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The component values to insert","lua_type":"ComponentInstance"}],"returns":[],"function_type":"method","source":{"line":611,"path":"lib/World.lua"}},{"name":"remove","desc":"Removes a component (or set of components) from an existing entity.\\n\\n```lua\\nlocal removedA, removedB = world:remove(entityId, ComponentA, ComponentB)\\n```","params":[{"name":"id","desc":"The entity ID","lua_type":"number"},{"name":"...","desc":"The components to remove","lua_type":"Component"}],"returns":[{"desc":"Returns the component instance values that were removed in the order they were passed.","lua_type":"...ComponentInstance"}],"function_type":"method","source":{"line":632,"path":"lib/World.lua"}},{"name":"size","desc":"Returns the number of entities currently spawned in the world.","params":[],"returns":[],"function_type":"method","source":{"line":660,"path":"lib/World.lua"}}],"properties":[],"types":[{"name":"ChangeRecord","desc":"","fields":[{"name":"new?","lua_type":"ComponentInstance","desc":"The new value of the component. Nil if just removed."},{"name":"old?","lua_type":"ComponentInstance","desc":"The former value of the component. Nil if just added."}],"source":{"line":443,"path":"lib/World.lua"}}],"name":"World","desc":"A World contains entities which have components.\\nThe World is queryable and can be used to get entities with a specific set of components.\\nEntities are simply ever-increasing integers.","source":{"line":46,"path":"lib/World.lua"}}')}}]);