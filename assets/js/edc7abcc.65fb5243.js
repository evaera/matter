"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[942],{5706:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Debugger.\\n\\nYou need to depend on [Plasma](https://eryn.io/plasma/) in your project and pass a handle to it here.","params":[{"name":"plasma","desc":"The instance of Plasma used in your game.","lua_type":"Plasma"}],"returns":[{"desc":"","lua_type":"Debugger"}],"function_type":"static","source":{"line":113,"path":"lib/debugger/debugger.lua"}},{"name":"show","desc":"Shows the debugger panel","params":[],"returns":[],"function_type":"method","realm":["Client"],"source":{"line":196,"path":"lib/debugger/debugger.lua"}},{"name":"hide","desc":"Hides the debugger panel","params":[],"returns":[],"function_type":"method","realm":["Client"],"source":{"line":209,"path":"lib/debugger/debugger.lua"}},{"name":"toggle","desc":"Toggles visibility of the debugger panel","params":[],"returns":[],"function_type":"method","realm":["Client"],"source":{"line":226,"path":"lib/debugger/debugger.lua"}},{"name":"autoInitialize","desc":"Adds middleware to your Loop to set up the debugger every frame.\\n\\n:::tip\\nThe debugger must also be shown on a client with [Debugger:show] or [Debugger:toggle] to be used.\\n:::\\n\\n:::caution\\n[Debugger:autoInitialize] should be called before [Loop:begin] to function as expected.\\n:::\\n\\nIf you also want to use Plasma for more than just the debugger, you can opt to not call this function and instead\\ndo what it does yourself.","params":[{"name":"loop","desc":"","lua_type":"Loop"}],"returns":[],"function_type":"method","source":{"line":313,"path":"lib/debugger/debugger.lua"}},{"name":"replaceSystem","desc":"Alert the debugger when a system is hot reloaded.","params":[{"name":"old","desc":"","lua_type":"System"},{"name":"new","desc":"","lua_type":"System"}],"returns":[],"function_type":"method","source":{"line":381,"path":"lib/debugger/debugger.lua"}},{"name":"switchToServerView","desc":"Switch the client to server view. This starts the server debugger if it isn\'t already started.","params":[],"returns":[],"function_type":"method","realm":["Client"],"source":{"line":392,"path":"lib/debugger/debugger.lua"}},{"name":"switchToClientView","desc":"Switch the client to client view. This stops the server debugger if there are no other players connected.","params":[],"returns":[],"function_type":"method","source":{"line":413,"path":"lib/debugger/debugger.lua"}},{"name":"update","desc":"This should be called to draw the debugger UI.\\n\\nThis is automatically set up when you call [Debugger:autoInitialize], so you don\'t need to call this yourself unless\\nyou didn\'t call `autoInitialize`.","params":[],"returns":[],"function_type":"method","source":{"line":437,"path":"lib/debugger/debugger.lua"}},{"name":"getWidgets","desc":"Returns a handle to the debug widgets you can pass to your systems.\\n\\nAll [plasma widgets](https://eryn.io/plasma/api/Plasma#arrow) are available under this namespace.\\n\\n```lua\\n-- ...\\nlocal debugger = Debugger.new(Plasma)\\n\\nlocal loop = Loop.new(world, state, debugger:getWidgets())\\n```\\n\\nWhen the Debugger is not open, calls to widgets are no-ops.\\n\\nIf the widget normally returns a handle (e.g., button returns a table with `clicked`), it returns a static dummy\\nhandle that always returns a default value:\\n\\n- `checkbox`\\n\\t- `clicked`: false\\n\\t- `checked`: false\\n- `button`\\n\\t- `clicked`: false\\n- `slider`: 0","params":[],"returns":[{"desc":"","lua_type":"{[string]: Widget}"}],"function_type":"method","source":{"line":473,"path":"lib/debugger/debugger.lua"}}],"properties":[{"name":"authorize","desc":"Create this property in Debugger to specify a function that will be called to determine if a player should be\\nallowed to connect to the server-side debugger.\\n\\nIf not specified, the default behavior is to allow anyone in Studio and disallow everyone in a live game.\\n\\n```lua\\ndebugger.authorize = function(player)\\n\\tif player:GetRankInGroup(372) > 250 then -- etc\\n\\t\\treturn true\\n\\tend\\nend\\n```","lua_type":"(player: Player) -> boolean","source":{"line":82,"path":"lib/debugger/debugger.lua"}},{"name":"findInstanceFromEntity","desc":"Create this property in Debugger to specify a function that will be called to determine what Instance is associated\\nwith an entity. This is used for the in-world highlight in the World inspector.\\n\\nIf not specified, the in-world highlight will not work.\\n\\n```lua\\ndebugger.findInstanceFromEntity = function(id)\\n\\tif not world:contains(id) then\\n\\t\\treturn\\n\\tend\\n\\n\\tlocal model = world:get(id, components.Model)\\n\\n\\treturn model and model.model or nil\\nend\\n```","lua_type":"(entityId: number) -> Instance?","source":{"line":104,"path":"lib/debugger/debugger.lua"}}],"types":[],"name":"Debugger","desc":"Attaches a Debugger to the Matter instance, allowing you to create debug widgets in your systems.\\n\\n```lua\\nlocal debugger = Matter.Debugger.new(Plasma)\\n\\nlocal widgets = debugger:getWidgets()\\nlocal loop = Matter.Loop.new(world, widgets) -- pass the widgets to your systems\\n\\ndebugger:autoInitialize(loop)\\n\\nif IS_CLIENT then\\n\\tdebugger:show()\\nend\\n```\\n\\nWhen the debugger is not open, the widgets do not render.","source":{"line":62,"path":"lib/debugger/debugger.lua"}}')}}]);