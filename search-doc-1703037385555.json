[{"title":"Component","type":0,"sectionRef":"#","url":"/matter/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/matter/api/Component#types","content":" "},{"title":"ComponentInstance​","type":1,"pageTitle":"Component","url":"/matter/api/Component#ComponentInstance","content":"&lt;/&gt; type ComponentInstance = {} The ComponentInstance type refers to an actual piece of data that can exist on an entity. The metatable of the component instance table is set to its particular Component table. A component instance can be created by calling the Component table: -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; }) print(getmetatable(myComponentInstance) == MyComponent) --&gt; true  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/matter/api/Component#functions","content":" "},{"title":"patch​","type":1,"pageTitle":"Component","url":"/matter/api/Component#patch","content":"&lt;/&gt; Component:patch( partialNewData: {}-- The table to be merged with the existing component data. ) → ComponentInstance-- A copy of the component instance with values from partialNewData overriding existing values. for id, target in world:query(Target) do if shouldChangeTarget(target) then world:insert(id, target:patch({ -- modify the existing component currentTarget = getNewTarget() })) end end A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table will override those of the existing component instance. As all components are immutable and frozen, it is not possible to modify the existing component directly. You can use the Matter.None constant to remove a value from the component instance: target:patch({ currentTarget = Matter.None -- sets currentTarget to nil })  "},{"title":"Derived state","type":0,"sectionRef":"#","url":"/matter/docs/BestPractices/DerivedState","content":"Derived state Oftentimes, games will have state that needs to be affected by multiple, distinct gameplay systems. For example, imagine you had a game where equipping a heavy weapon lowered your walk speed. There might be other things that affect your walk speed too, like being Poisoned! So, let's say both equipping the heavy weapon and being poisoned both need to lower your player's walk speed. Instead of directly controlling the walk speed in the weapon system and then again in the poison system, we should make a dedicated system to manage walk speed. Let's say that whenever a player is poisoned or has a heavy weapon equipped, our game adds the Poison or HeavyWeapon components to the player entity. For the sake of this example, we can imagine that each one lowers walk speed by half. local affectsWalkSpeed = {Poison, HeavyWeapon} local function walkSpeed(world) for id, player in world:query(Player) do local results = {world:get(id, unpack(affectsWalkSpeed))} -- NOTE: You can't be tricky by just checking the length of this table! -- We MUST iterate over it because the Lua length operator does not work -- as you might expect when a table has nil values in it. -- See for yourself: Lua says #{nil,nil,nil,1,nil} is 0! local modifier = 1 for _ in results do -- For each result, reduce speed by half. modifier *= 0.5 end -- The default Roblox walk speed is 16 local speed = 16 * modifier world:insert(id, WalkSpeed({ speed = speed, modifier = modifier, })) end end return walkSpeed By listing out everything that can affect the walk speed in this system, we've created one source of truth for the player's walk speed. Any time there's a bug or something wrong with player movement, just check this one file. It's much easier to track down changes when everything that can affect something is in one place. The value of the WalkSpeed component we use here is completely derived from the state of other components on the entity. This is derived state! Maybe in a separate system, we could update anything with a Model and a WalkSpeed component, perhaps: -- Update anything with WalkSpeed and Model (this could be a separate system) for id, walkSpeed, model in world:query(WalkSpeed, Model) do if model.model:FindFirstChild(&quot;Humanoid&quot;) then model.model.Humanoid.WalkSpeed = walkSpeed.speed end end ","keywords":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/matter/docs/GettingStarted","content":"","keywords":""},{"title":"Scaffolding a new project​","type":1,"pageTitle":"Getting Started","url":"/matter/docs/GettingStarted#scaffolding-a-new-project","content":"Here's how you scaffold a project with Matter. First, import Matter at the top of your file. Then, create your World and your Loop. init.server.lua local Matter = require(ReplicatedStorage.Matter) local world = Matter.World.new() local loop = Matter.Loop.new(world) -- This makes Loop pass the world to all your systems.  Then, we should collect all of your systems and schedule them. Assuming they're in a systems folder inside this script: init.server.lua local systems = {} for _, child in ipairs(script.systems:GetChildren()) do if child:IsA(&quot;ModuleScript&quot;) then table.insert(systems, require(child)) end end loop:scheduleSystems(systems)  Then, simply start the loop. init.server.lua loop:begin({ default = RunService.Heartbeat })  Now your systems would run every heartbeat, if you had any. Let's make some. systems/myFirstSystem.lua local function myFirstSystem() print(&quot;Hello world!&quot;) end return myFirstSystem  Now we're printing something 60 times per second. We should probably do something actually interesting instead. Let's create a couple components. components.lua local Matter = require(ReplicatedStorage.Matter) return { Health = Matter.component(), Poison = Matter.component(), }  Let's make a system that removes 0.1 health every frame from things that are poisoned. systems/poisonHurts.lua local Components = require(script.Parent.components) local Health = Components.Health local Poison = Components.Poison local function poisonHurts(world) for id, health in world:query(Health, Poison) do world:insert(id, health:patch({ value = health.value - 0.1 })) end end  We make use of the Component:patch function, which returns a new component with an updated value, so we don't have to mutate the existing component. "},{"title":"Next steps​","type":1,"pageTitle":"Getting Started","url":"/matter/docs/GettingStarted#next-steps","content":"You should dive in to the API reference! The Matter API is simple and documented in detail. And if you haven't already, check out the /example directory in the matter repo. "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"/matter/api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"/matter/api/QueryResult#functions","content":" "},{"title":"next​","type":1,"pageTitle":"QueryResult","url":"/matter/api/QueryResult#next","content":"&lt;/&gt; QueryResult:next() → ( id,-- Entity ID ...ComponentInstance-- The requested component values ) Returns the next set of values from the query result. Once all results have been returned, the QueryResult is exhausted and is no longer useful. info This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly done by the language itself. -- Using world:query in this position will make Lua invoke the table as a function. This is conventional. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call next directly instead of calling the QueryResult as a function. local id, enemy, charge, model = world:query(Enemy, Charge, Model):next() local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional   "},{"title":"snapshot​","type":1,"pageTitle":"QueryResult","url":"/matter/api/QueryResult#snapshot","content":"&lt;/&gt; QueryResult:snapshot() → {{ entityId: number, component: ComponentInstance, component: ComponentInstance, component: ComponentInstance, ... }} Creates a &quot;snapshot&quot; of this query, draining this QueryResult and returning a list containing all of its results. By default, iterating over a QueryResult happens in &quot;real time&quot;: it iterates over the actual data in the ECS, so changes that occur during the iteration will affect future results. By contrast, QueryResult:snapshot() creates a list of all of the results of this query at the moment it is called, so changes made while iterating over the result of QueryResult:snapshot do not affect future results of the iteration. Of course, this comes with a cost: we must allocate a new list and iterate over everything returned from the QueryResult in advance, so using this method is slower than iterating over a QueryResult directly. The table returned from this method has a custom __iter method, which lets you use it as you would use QueryResult directly: for entityId, health, player in world:query(Health, Player):snapshot() do end However, the table itself is just a list of sub-tables structured like {entityId, component1, component2, ...etc}.  "},{"title":"without​","type":1,"pageTitle":"QueryResult","url":"/matter/api/QueryResult#without","content":"&lt;/&gt; QueryResult:without( ...: Component-- The component types to filter against. ) → () → ( id, ...ComponentInstance )-- Iterator of entity ID followed by the requested component values Returns an iterator that will skip any entities that also have the given components. tip This is essentially equivalent to querying normally, using World:get to check if a component is present, and using Lua's continue keyword to skip this iteration (though, using :without is faster). This means that you should avoid queries that return a very large amount of results only to filter them down to a few with :without. If you can, always prefer adding components and making your query more specific. for id in world:query(Target):without(Model) do -- Do something end  "},{"title":"Core Concepts","type":0,"sectionRef":"#","url":"/matter/docs/Concepts","content":"","keywords":""},{"title":"Entities​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#entities","content":"An entity represents something in your game. It might be a player character, an enemy, or a tree. Generally, you will have one entity per thing you want to represent in your game. In Matter (as well as a typical ECS), an entity is just a unique number. "},{"title":"Components​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#components","content":"Components are pieces of data that you can attach to entities. Since entities are just numbers, all the information about an entity is stored in its components. Components are data structures that you define and reuse across many different entities. For example, you might define a Health component, which has two fields: current and max. You can then reuse the Health component across many different entities. You might add it to both player entities and enemy entites. Or even a tree, if you have trees that can take damage. An important distinction between a more object-oriented way of thinking and ECS is that instead of having an object that has methods and fields (Enemy class to represent an enemy), entities are much more flexible. There is really no such thing as an &quot;enemy entity&quot; or &quot;tree entity&quot;. Instead, there are entities that have the Enemy component, or have the Tree component. It's possible, then, for there to be an entity that has both the Enemy and Tree components. You might also give it the Health component if you want it to be able to take damage. So, instead of thinking about things based on what they are, we instead think of the in terms of characteristics that they have. This creates a much more flexible data model and enables code reuse in ways that are difficult to achieve with an inheritance-based object-oriented model. "},{"title":"World​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#world","content":"A World is an object that contains all of your entities and all of their components. You will usually only have one World in your game. You create it when your game starts. (See: GettingStarted) You can create entities in your World by using the World:spawn method: local newEntityId = world:spawn( Enemy(), Health({ current = 100, max = 100, }), Name({ name = &quot;Evil Tree&quot; }), Tree({ type = &quot;oak&quot; }) )  Now, the new entity has been created with all of our specified components. We got back the new entity ID (just a number) and stored it in the variable newEntityid. We can get a specific component like this: local nameComponent = world:get(newEntityId, Name) print(nameComponent.name)  Here's a quick, incomplete reference of the things you can do: Method\tDescriptionspawn\tspawn a new entity with given components insert\tAdd new or replace an existing component on an existing entity get\tGet a specific component or set of components from an existing entity remove\tRemove a component from an existing entity. despawn\tRemove all components from an entity and delete the entity. contains\tCheck whether or not an entity still exists in the world. Check out the World API reference to see everything else you can do! "},{"title":"Systems​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#systems","content":"Since components are just data, we need a way to actually... do things! This is where Systems come in. A system is just a function that runs every frame in a specific order alongside your other systems. Typically, a system only does one job, using a specific set of components. We can reuse our Health component from earlier. Let's say that in our game, we want anything with health to regenerate its HP over time. Remember, we don't care about what the things actually are that we are dealing with here. We don't care if it's a player, an enemy, or a tree: all we know is that it has health. A good way to name systems is by declaring something about the world that they do. In this case: &quot;Health Regenerates.&quot; healthRegenerates.lua for id, health in world:query(Health) do if health.current &lt; health.max then world:insert(id, health:patch({ -- Regenerate 0.1% of maximum health per frame current = math.min(health.max, health.current + (health.max * 0.001)) }) end end  In the above code sample, we use the World:query method to loop over everything in the world that has Health, and regenerate some. You can also query for multiple components at once, i.e. if you only wanted to select Players with Health. Then, you will only get entities that have both components. Systems can also interact with Roblox Instances and change things through side effects. The Reconciliation page goes over this in more detail. "},{"title":"Loop​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#loop","content":"The Loop object in Matter is a simple way to handle running your Systems in the same order every frame. This is covered on the GettingStarted page. It's not technically required, but makes setting up Matter much easier and enables some topologically-aware features. "},{"title":"Topologically-aware functions​","type":1,"pageTitle":"Core Concepts","url":"/matter/docs/Concepts#topologically-aware-functions","content":"Many functions in matter are topologically-aware: this means that they store some state which is referenced by the file and line number where the function is called from. useEvent, useThrottle, and World:queryChanged are all examples. This works in a similar way to &quot;hooks&quot; from React/Roact, and so we often refer to topologically-aware functions with the term &quot;hook&quot;. Under the hood, Matter creates and stores state that these functions use and references them by the call location, in contrast to having to come up with a name or place to store it yourself. The script name and line number become the way that we identify the state storage for whatever function you called. This only works when your Systems are invoked by a Matter Loop. You can learn more about this and even implement your own topologically-aware functions on the useHookState docs. "},{"title":"Debugger","type":0,"sectionRef":"#","url":"/matter/api/Debugger","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#properties","content":" "},{"title":"authorize​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#authorize","content":"&lt;/&gt; Debugger.authorize: (player: Player ) → boolean Create this property in Debugger to specify a function that will be called to determine if a player should be allowed to connect to the server-side debugger. If not specified, the default behavior is to allow anyone in Studio and disallow everyone in a live game. debugger.authorize = function(player) if player:GetRankInGroup(372) &gt; 250 then -- etc return true end end   "},{"title":"findInstanceFromEntity​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#findInstanceFromEntity","content":"&lt;/&gt; Debugger.findInstanceFromEntity: (entityId: number) → Instance?  Create this property in Debugger to specify a function that will be called to determine what Instance is associated with an entity. This is used for the in-world highlight in the World inspector. If not specified, the in-world highlight will not work. debugger.findInstanceFromEntity = function(id) if not world:contains(id) then return end local model = world:get(id, components.Model) return model and model.model or nil end   "},{"title":"componentRefreshFrequency​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#componentRefreshFrequency","content":"&lt;/&gt; Debugger.componentRefreshFrequency: number Create this property in Debugger to specify the frequency (in seconds) that the unique component list will refresh. If not specified, it will use a default time of 3 seconds. debugger.componentRefreshFrequency = 1  "},{"title":"Functions​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#new","content":"&lt;/&gt; Debugger.new( plasma: Plasma-- The instance of Plasma used in your game. ) → Debugger Creates a new Debugger. You need to depend on Plasma in your project and pass a handle to it here.  "},{"title":"show​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#show","content":"This item only works when running on the client. Client &lt;/&gt; Debugger:show() → () Shows the debugger panel  "},{"title":"hide​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#hide","content":"This item only works when running on the client. Client &lt;/&gt; Debugger:hide() → () Hides the debugger panel  "},{"title":"toggle​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#toggle","content":"This item only works when running on the client. Client &lt;/&gt; Debugger:toggle() → () Toggles visibility of the debugger panel  "},{"title":"autoInitialize​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#autoInitialize","content":"&lt;/&gt; Debugger:autoInitialize(loop: Loop) → () Adds middleware to your Loop to set up the debugger every frame. tip The debugger must also be shown on a client with Debugger:show or Debugger:toggle to be used. caution Debugger:autoInitialize should be called before Loop:begin to function as expected. If you also want to use Plasma for more than just the debugger, you can opt to not call this function and instead do what it does yourself.  "},{"title":"replaceSystem​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#replaceSystem","content":"&lt;/&gt; Debugger:replaceSystem( old: System, new: System ) → () Alert the debugger when a system is hot reloaded.  "},{"title":"switchToServerView​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#switchToServerView","content":"This item only works when running on the client. Client &lt;/&gt; Debugger:switchToServerView() → () Switch the client to server view. This starts the server debugger if it isn't already started.  "},{"title":"switchToClientView​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#switchToClientView","content":"&lt;/&gt; Debugger:switchToClientView() → () Switch the client to client view. This stops the server debugger if there are no other players connected.  "},{"title":"update​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#update","content":"&lt;/&gt; Debugger:update() → () This should be called to draw the debugger UI. This is automatically set up when you call Debugger:autoInitialize, so you don't need to call this yourself unless you didn't call autoInitialize.  "},{"title":"getWidgets​","type":1,"pageTitle":"Debugger","url":"/matter/api/Debugger#getWidgets","content":"&lt;/&gt; Debugger:getWidgets() → {[string]: Widget} Returns a handle to the debug widgets you can pass to your systems. All plasma widgets are available under this namespace. -- ... local debugger = Debugger.new(Plasma) local loop = Loop.new(world, state, debugger:getWidgets()) When the Debugger is not open, calls to widgets are no-ops. If the widget normally returns a handle (e.g., button returns a table with clicked), it returns a static dummy handle that always returns a default value: checkbox clicked: false checked: false button clicked: false slider: 0 "},{"title":"State Machines","type":0,"sectionRef":"#","url":"/matter/docs/BestPractices/StateMachines","content":"","keywords":""},{"title":"Components as state machines​","type":1,"pageTitle":"State Machines","url":"/matter/docs/BestPractices/StateMachines#components-as-state-machines","content":"Now that you (hopefully) understand state machines, we can relate this to components in an ECS. While some components are mostly static or just update as data changes (like a component that holds the player's current Walk Speed), other components might be a little bit more complex. Imagine we had a car that we want to drive from point A to point B, then from point B to point C, then from C to D, etc. How do we store what point the car is currently at, and which to go to next? This is where treating your component as a state machine come in. You can have your component data represent a state in a state machine, and your system code progresses that component one step forward, into the next state. Our Car component could have an array of Vector3s in it, the points we want to visit: world:spawn(Car({ destinations = {Vector3.new(0, 0, 0), Vector3.new(10, 0, 5), Vector3.new(-5, 2, 3)} }))  In our system code, we can drive the car towards one of the points, and when it reaches its destination, remove that item from the list and start going towards the next. for id, car, model in world:query(Car, Model) do local currentPosition = model.model.PrimaryPart.Position if (currentPosition - car.destinations[1]).magnitude &lt; 2 then -- Arrived table.remove(car.destinations, 1) if #car.destinations == 0 then world:despawn(id) continue end end model.model.PrimaryPart.BodyPosition.Position = car.destinations[1] --example end  In this way, our system &quot;steps&quot; our component forward in time, modifying it when necessary. "},{"title":"Adding another layer​","type":1,"pageTitle":"State Machines","url":"/matter/docs/BestPractices/StateMachines#adding-another-layer","content":"We can make this a little bit more complicated if we make the car wait at each destination once it arrives. world:spawn(Car({ destinations = {Vector3.new(0, 0, 0), Vector3.new(10, 0, 5), Vector3.new(-5, 2, 3)}, mode = &quot;driving&quot; })) ----- for id, car, model in world:query(Car, Model) do if car.mode == &quot;waiting&quot; then if os.clock() - car.startedWaiting &gt; 5 then -- Wait 5 seconds world:insert(id, car:patch({ mode = &quot;driving&quot;, startedWaiting = Matter.None })) end elseif car.mode == &quot;driving&quot; then if #car.destinations == 0 then world:despawn(id) continue end local currentPosition = model.model.PrimaryPart.Position if (currentPosition - car.destinations[1]).magnitude &lt; 2 then -- Arrived table.remove(car.destinations, 1) world:insert(id, car:patch({ mode = &quot;waiting&quot;, startedWaiting = os.clock() })) continue end model.model.PrimaryPart.BodyPosition.Position = car.destinations[1] --example end end  Now, we've added another layer to our Car component: a mode property, that tells our code if the car is waiting or driving. You can see how this could get even more complex, adding other modes, arrays to drain, and other state that allows our system to &quot;step&quot; our component forward in time. "},{"title":"Hot reloading","type":0,"sectionRef":"#","url":"/matter/docs/Guides/HotReloading","content":"","keywords":""},{"title":"Setting up hot reloading in your game​","type":1,"pageTitle":"Hot reloading","url":"/matter/docs/Guides/HotReloading#setting-up-hot-reloading-in-your-game","content":""},{"title":"Installing rewire​","type":1,"pageTitle":"Hot reloading","url":"/matter/docs/Guides/HotReloading#installing-rewire","content":"We recommend using the rewire library for easy hot reloading. You can install Rewire using Wally, the Roblox open source package manager. wally.toml [dependencies] rewire = &quot;sayhisam1/rewire@0.3.0&quot;  "},{"title":"Set up Rewire​","type":1,"pageTitle":"Hot reloading","url":"/matter/docs/Guides/HotReloading#set-up-rewire","content":"In the code where you create your Matter Loop object, create a new HotReloader object: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Packages = ReplicatedStorage.Packages local HotReloader = require(Packages.rewire).HotReloader local hotReloader = HotReloader.new()  Then, we call HotReloader:scan, passing in the folder that contains your systems, and two functions: one that runs when a system is loaded, and another that runs when a system is unloaded. local firstRunSystems = {} local systemsByModule = {} hotReloader:scan(container, function(module, context) -- The module HotReloader gives us can be a clone of the original module if it's been hot reloaded. local originalModule = context.originalModule -- Load the cloned module. If it has syntax errors, require will error. local ok, system = pcall(require, module) if not ok then warn(&quot;Error when hot-reloading system&quot;, module.name, system) return end if firstRunSystems then -- On the first run, we want to schedule all systems in one call, -- so we buffer them up and call one big `loop:scheduleSystems` at the end. table.insert(firstRunSystems, system) elseif systemsByModule[originalModule] then -- If this system was already loaded once before, we tell the loop to replace it. loop:replaceSystem(systemsByModule[originalModule], system) -- If you're also using the Matter debugger, tell the debugger the system was reloaded. -- debugger:replaceSystem(systemsByModule[originalModule], system) else -- If this is a new system (i.e., a new module was created during a hot reload), just schedule it. loop:scheduleSystem(system) end -- Keep a reference to the system, keyed by the original module, so we can detect if the system already existed -- or not systemsByModule[originalModule] = system end, function(_, context) -- This function runs when a system is being unloaded. -- context.isReloading is true if the system is about to be hot reloaded. Otherwise, it's been removed. -- If it's being hot reloaded, do nothing if context.isReloading then return end -- The system is being removed local originalModule = context.originalModule if systemsByModule[originalModule] then -- If the system was loaded, remove it from the loop loop:evictSystem(systemsByModule[originalModule]) systemsByModule[originalModule] = nil end end)  That's it! For a real example of this in action, check out the Matter example game. "},{"title":"Reconciliation","type":0,"sectionRef":"#","url":"/matter/docs/BestPractices/Reconciliation","content":"","keywords":""},{"title":"The Data Model​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#the-data-model","content":"In Roblox, the Data Model is the tree of instances which embodies all the things in your game. In Lua, the game global is assigned to the root of this tree, whose class is DataModel. The Data Model is also sometimes called the DOM (Document Object Model), a term borrowed from the Web world. When making a game on Roblox, whether a conscious decision or not, the source of truth for game state lives in either in some Lua data structure (e.g., a table), or in the Data Model itself. As an example, the Humanoid object has a Health field. Most games on Roblox use the Humanoid's Health field as the source of truth for players. Thus, the source of truth for player health lives in the Data Model. On the other hand, imagine in your game players can earn points by completing objectives. You create a table which maps players to the number of points they have (e.g., {[Player]: number}). To display the points to the player, you update some text in the game every time the points change. This is an example of the source of truth living in your own code: the points map is the source of truth, and you update the DataModel to reflect this. Many games use a mix of these two ideas for different pieces of state. While this can work, it can lead to problems down the line. Largely, these problems are caused by the instances and properties available in the DataModel being unable to adequately represent complex game state in a convenient way. Developers are forced to contort their game state around what's available in the DataModel, which makes code difficult to reason about. Attributes are an attempt to help solve this problem, but ultimately fall short due to design limitations. You cannot create an attribute with a complex data structure, only primitive values are allowed. And, attributes must be placed on existing instance types, which hamstrings the developer's ability to have control over the state of their own game. Code becomes simpler to reason about if we instead treat Instances and the Data Model as a sort of intermediate representation of our game's state, which is only derived from our true game state: some data structure (e.g., tables) that we keep in Lua. This is what the ECS world is: it's a place where you can structure your game state however you want, optimized for fast batch operations. There are other approaches to storing game state (e.g. object-oriented classes and encapsulation), but this is an ECS library, so that's what we'll focus on. "},{"title":"Reconciliation​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#reconciliation-1","content":"Reconciliation, in this context, means taking state from one form and turning it into another. In our case, we want to reconcile our Lua state into Instances in the Data Model, so that users can see and interact with it. A key idea and benefit of reconciliation is that it's possible to reconcile the same state in multiple different ways. If we have enemies in our world at certain positions, we can reconcile them into the world with character models, but also onto a minimap with red blips. It's the same state being converted into two different ways to view the data. When writing code in an ECS like Matter, it's ideal for all of our gameplay code to operate on the ECS world alone. In the Matter example game, for example, there are ships that fly to certain points in space. For example, instead of updating the ships in the Data Model directly, we store the current goal position in the Ship component. The Ship component knows nothing about the Data Model. It has no reference to the physical ship Instance in the Data Model, it only contains the state about the ship. We can create another component (in the Matter example game, we call it Model) that holds a reference to the ship Instance. We can loop over all Ships that don't also have a Model, and create one for it. ships.lua for id, ship in world:query(Ship):without(Model) do local model = prefabs.Ship:Clone() -- assuming prefabs is a place where you store pre-made models model.Parent = workspace world:insert(id, Model({ instance = model })) end  Now, whenever there's an entity with Ship without Model, we create the model and insert the Model component. We can then loop over all Ships that have Models, and update the position of the Model. ships.lua for id, ship, model in world:query(Ship, Model) do model.instance.BodyPosition.Position = ship.goalPosition end  Keep in mind, both of these loops are performed every frame - that's what a system does. This means that in order to create a Ship from some other system, we need only spawn an entity with Ship - this system we just wrote takes care of creating and further reconciling the state of the Ship into the Data Model. We have a problem now, though: whenever an entity with both Ship and Model is despawned, the physical ship Instance in the Data Model will stick around. Since the Model component is generic and could be reused with any other component (it's not specific to just Ship), we can create another system that handles this case for anything that uses Model. removeModels.lua for _id, modelRecord in world:queryChanged(Model) do if modelRecord.new == nil then if modelRecord.old and modelRecord.old.instance then modelRecord.old.instance:Destroy() end end end  Here, we use queryChanged to loop over Model components that have changed in the last frame. queryChanged gives us a ChangeRecord type, which is a table with old and new properties. If there was an old instance, but no new instance, we know that the Model component has been removed. This can happen when the Model component is removed but the entity still exists (e.g., world:remove(entityId, Model) and also when the entire entity is despawned (e.g., world:despawn(entityId)). We then call Instance:Destroy() on the Instance. Now that we've written this code once for our game, it will operate on any entity that has a Model component. This means that calling world:despawn on an entity with Ship and Model will result in the physical Instance also being removed. "},{"title":"Reverse bindings​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#reverse-bindings","content":""},{"title":"Events​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#events","content":"While we generally want our state to flow in one direction (Lua into the DataModel), we must also be able to interact with the things we've created. Roblox Instances have events that fire, (e.g., Touched) which are still things we need to use. As an example, let's say we wanted the Ship to despawn if it was touched by anything. We can use Matter's useEvent utility to collect events that fire in a frame and loop over them. ships.lua for id, model in world:query(Model, Ship) do for _ in Matter.useEvent(model.Instance, &quot;Touched&quot;) do world:despawn(id) end end  "},{"title":"Removal​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#removal","content":"Sometimes, instances can be removed from the Data Model or destroyed without us doing it. A common cause of this is because parts that are affected by physics fall below the world or get flung to infinity. This can result in those instances being removed without us doing so. To account for this, we can simply loop over every Model and check if it's still in the world. If not, we can either remove the Model component or despawn the entire entity (whichever makes more sense for your game). removeModels.lua for id, model in world:query(Model) do if model.instance:IsDescendantOf(game) == false then world:remove(id, Model) end end  As a side effect, the above code makes it so manually deleting an Instance in a play test in Studio will cause it to be instantly recreated in the same place. This may or may not be the behavior that you want, but it sure is interesting! It should be noted that this method can cause an infinite loop of a Model being created and destroyed if the last Transform was at an invalid position. This can be solved by either just despawning the entire entity instead, or taking care to reset Transform to a known-safe position when removing models. "},{"title":"Two-way bindings​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#two-way-bindings","content":"Imagine we had a component that held the position and rotation of something. This is often called Transform. Our Transform component would hold a CFrame value. There are two potential ways we could want to use this component: We want to update our Transform component and have the physical Instance be moved to that place.We want the Transform component to be updated based on where the Instance is in the world, because physics can move it around. We can make a system that handles both of these cases for us. updateTransforms.lua -- Handle Transform added/changed to existing entity with Model for id, transformRecord in world:queryChanged(Transform) do local model = world:get(id, Model) -- Take care to ignore the changed event if it was us that triggered it if model and transformRecord.new and not transformRecord.new.doNotReconcile then model.instance:SetPrimaryPartCFrame(transformRecord.new.cframe) end end -- Handle Model added/changed on existing entity with Transform for id, modelRecord in world:queryChanged(Model) do local transform = world:get(id, Transform) if transform and modelRecord.new then modelRecord.new.model:SetPrimaryPartCFrame(transform.cframe) end end -- Update Transform on unanchored Models for id, model, transform in world:query(Model, Transform) do if model.instance.PrimaryPart.Anchored then continue end local existingCFrame = transform.cframe local currentCFrame = model.instance.PrimaryPart.CFrame -- Only insert if actual position is different from the Transform component if currentCFrame ~= existingCFrame then world:insert( id, Components.Transform({ cframe = currentCFrame, doNotReconcile = true, }) ) end end  The above system handles the following cases: When the Transform component is inserted on an entity that also has Model, move the Model to that position.*When the Model component is inserted on an entity that also has Transform, move the Model to that position.When an unanchored Model moves, update the Transform component to match its new position. * We only update the Transform component if it wasn't us that caused it to move. "},{"title":"Benefits of reconciliation​","type":1,"pageTitle":"Reconciliation","url":"/matter/docs/BestPractices/Reconciliation#benefits-of-reconciliation","content":"When we structure our game code in this manner, it allows us to do some cool things. For example: Creating a new entity (like a ship) from other systems is as simple as just spawning an entity with a Ship component. We don't have to worry about creating the model for it, because the ship system will look for Ships without Models and make them for us.Likewise, despawning an entity does what we expect. We can just despawn it from any system, and our generic model system will handle cleaning up the model.We don't need to access the Model component of a ship to know where it is in the world, we only need to read the Transform component, even if it's affected by physics. Likewise, to move a ship, we only need to write to (insert) the Transform component.We could copy the entire ECS world at a given point in time, since it's just plain-old data1, and then restore it later. Our systems won't know the difference: models that didn't exist and now do will be created, models that exist now but didn't before will be destroyed, and models that still exist will snap into the correct position.We can reconcile the same state multiple times into the world, like marking ships on a minimap. If saving the data, we would need to take special care to serialize things like CFrame values and Vector3 into JSON-compatible data, but that's beyond the scope of this article↩ "},{"title":"Using CollectionService tags","type":0,"sectionRef":"#","url":"/matter/docs/Guides/CollectionService","content":"Using CollectionService tags As a pure ECS first and foremost, Matter provides no special functionality for CollectionService tags out of the box. However, it's rather simple to implement this yourself. Here's an example taken from the official Matter example game. local CollectionService = game:GetService(&quot;CollectionService&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Components = require(ReplicatedStorage.Game.components) local boundTags = { Spinner = Components.Spinner, } local function setupTags(world) local function spawnBound(instance, component) local id = world:spawn( component(), Components.Model({ model = instance, }), Components.Transform({ cframe = instance.PrimaryPart.CFrame, }) ) instance:SetAttribute(&quot;entityId&quot;, id) end for tagName, component in pairs(boundTags) do for _, instance in ipairs(CollectionService:GetTagged(tagName)) do spawnBound(instance, component) end CollectionService:GetInstanceAddedSignal(tagName):Connect(function(instance) spawnBound(instance, component) end) CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(instance) local id = instance:GetAttribute(&quot;entityId&quot;) if id then world:despawn(id) end end) end end return setupTags This example can be modified to meet your game's needs as you see fit.","keywords":""},{"title":"Loop","type":0,"sectionRef":"#","url":"/matter/api/Loop","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#types","content":" "},{"title":"System​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#System","content":"&lt;/&gt; type System = SystemTable | (...any) → () Either a plain function or a table defining the system.  "},{"title":"SystemTable​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#SystemTable","content":"&lt;/&gt; interface SystemTable { system: (...any) → ()-- The system function event?: string-- The event the system runs on. A string, a key from the table you pass to Loop:begin. priority?: number-- Priority influences the position in the frame the system is scheduled to run at. after?: {System}-- A list of systems that this system must run after. } A table defining a system with possible options. Systems are scheduled in order of priority, meaning lower priority runs first. The default priority is 0. "},{"title":"Functions​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#new","content":"&lt;/&gt; Loop.new( ...: ...any-- Values that will be passed to all of your systems ) → Loop Creates a new loop. Loop.new accepts as arguments the values that will be passed to all of your systems. So typically, you want to pass the World in here, as well as maybe a table of global game state. local world = World.new() local gameState = {} local loop = Loop.new(world, gameState)   "},{"title":"scheduleSystems​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#scheduleSystems","content":"&lt;/&gt; Loop:scheduleSystems( systems: {System}-- Array of systems to schedule. ) → () Schedules a set of systems based on the constraints they define. Systems may optionally declare: The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat) A numerical priority value Other systems that they must run after If systems do not specify an event, they will run on the default event. Systems that share an event will run in order of their priority, which means that systems with a lower priority value run first. The default priority is 0. Systems that have defined what systems they run after can only be scheduled after all systems they depend on have already been scheduled. All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems will always run in the same order across machines. info It is possible for your systems to be in an unresolvable state. In which case, scheduleSystems will error. This can happen when your systems have circular or unresolvable dependency chains. If a system has both a priority and defines systems it runs after, the system can only be scheduled if all of the systems it depends on have a lower or equal priority. Systems can never depend on systems that run on other events, because it is not guaranteed or required that events will fire every frame or will always fire in the same order. caution scheduleSystems has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple times if possible.  "},{"title":"scheduleSystem​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#scheduleSystem","content":"&lt;/&gt; Loop:scheduleSystem(system: System) → () Schedules a single system. This is an expensive function to call multiple times. Instead, try batch scheduling systems with Loop:scheduleSystems if possible.  "},{"title":"evictSystem​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#evictSystem","content":"&lt;/&gt; Loop:evictSystem(system: System) → () Removes a previously-scheduled system from the Loop. Evicting a system also cleans up any storage from hooks. This is intended to be used for hot reloading. Dynamically loading and unloading systems for gameplay logic is not recommended.  "},{"title":"replaceSystem​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#replaceSystem","content":"&lt;/&gt; Loop:replaceSystem( old: System, new: System ) → () Replaces an older version of a system with a newer version of the system. Internal system storage (which is used by hooks) will be moved to be associated with the new system. This is intended to be used for hot reloading.  "},{"title":"begin​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#begin","content":"&lt;/&gt; Loop:begin( events: {[string]: RBXScriptSignal }-- A map from event name to event objects. ) → {[string]: RBXScriptConnection }-- A map from your event names to connection objects. Connects to frame events and starts invoking your systems. Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names to define what event they run on. By default, systems run on an event named &quot;default&quot;. Custom events may be used if they have a Connect function. loop:begin({ default = RunService.Heartbeat, Heartbeat = RunService.Heartbeat, RenderStepped = RunService.RenderStepped, Stepped = RunService.Stepped, }) Returns a table similar to the one you passed in, but the values are RBXScriptConnection values (or whatever is returned by :Connect if you passed in a synthetic event).  "},{"title":"addMiddleware​","type":1,"pageTitle":"Loop","url":"/matter/api/Loop#addMiddleware","content":"&lt;/&gt; Loop:addMiddleware(middleware: ( nextFn: () → (), eventName: string ) → () → ()) → () Adds a user-defined middleware function that is called during each frame. This allows you to run code before and after each frame, to perform initialization and cleanup work. loop:addMiddleware(function(nextFn) return function() Plasma.start(plasmaNode, nextFn) end end) You must pass addMiddleware a function that itself returns a function that invokes nextFn at some point. The outer function is invoked only once. The inner function is invoked during each frame event. info Middleware added later &quot;wraps&quot; middleware that was added earlier. The innermost middleware function is the internal function that actually calls your systems. "},{"title":"Matter","type":0,"sectionRef":"#","url":"/matter/docs/intro","content":"","keywords":""},{"title":"Goals​","type":1,"pageTitle":"Matter","url":"/matter/docs/intro#goals","content":"Simple, obvious APIPerformantGreat debuggability, error handling and insight into what's actually happening each frameCommon patterns are easy to fall into and hard to mess up "},{"title":"Non-goals​","type":1,"pageTitle":"Matter","url":"/matter/docs/intro#non-goals","content":"Many similar libraries, ECS or not, end up with a bloated API, requiring significant cognitive overhead to use. We want to avoid this as much as possible.We don't want to provide every thing the user could ever want in our library. Instead, it should be easy for users to write obvious code that does those things. "},{"title":"Performance today​","type":1,"pageTitle":"Matter","url":"/matter/docs/intro#performance-today","content":"Matter currently achieves an average frame time of 0.65ms spent inside Matter code for the following benchmark: World with 1000 entitiesBetween 2-30 components on each entity300 unique component types200 systemsEach system queries between 1 and 10 components "},{"title":"Prior art​","type":1,"pageTitle":"Matter","url":"/matter/docs/intro#prior-art","content":"Matter is inspired by hecs by Railith from the Rust ecosystem! "},{"title":"Common Mistakes","type":0,"sectionRef":"#","url":"/matter/docs/Guides/CommonMistakes","content":"","keywords":""},{"title":"Off by one frame insertions and queries​","type":1,"pageTitle":"Common Mistakes","url":"/matter/docs/Guides/CommonMistakes#off-by-one-frame-insertions-and-queries","content":"In Matter as well as any ECS, your systems run in a fixed order every frame. It's important to consider the order that your systems will run when writing code that deals with removing, inserting, and changing components on entities. For example, let's say that you have a system that moves NPCs to the correct position every frame. You might do this by querying over every entity with the NPC component and then moving its world model position. We can call this systemnpcUpdater. You might have another system responsible for spawning new NPCs (npcSpawner). If npcSpawner runsafter npcUpdater, newly spawned NPCs will be in their default position for one frame before jumping to their correct position the next. In addition to players potentially noticing an NPC quickly flash in and out of existence, it could cause cascading issues in other systems as well. When it comes to modifying entities, it's best to stick to this general order: Remove any entities or components early in the frame, so that no unnecessary work is performed by querying them laterSpawn entities or insert components next. Insert things before any systems that rely on them have a chance to query and potentially miss entities that are spawned late.Change existing entities next, so that you can update newly inserted components correctlyQueries that run over all of a certain component every frame last "},{"title":"Using return instead of continue in a query for loop​","type":1,"pageTitle":"Common Mistakes","url":"/matter/docs/Guides/CommonMistakes#using-return-instead-of-continue-in-a-query-for-loop","content":"This is a simple one. When querying, it's easy to just use the wrong control flow. Many of us are so used to writing code that early returns that it's easy to accidentally use return inside a for loop, when you really wanted continue. function mySystem(world) for id, health, poison in world:query(Health, Poison) do if not poison.active then return -- Oops! After reaching the first inactive poison, -- we're going to stop running the entire system! -- Should have used `continue` here. end world:insert(id, health:patch({ current = health.current - 1 })) end end  "},{"title":"Early return inside systems resetting topologically-aware state​","type":1,"pageTitle":"Common Mistakes","url":"/matter/docs/Guides/CommonMistakes#early-return-inside-systems-resetting-topologically-aware-state","content":"Many functions in matter are topologically-aware: this means that they store some state which is referenced by the file and line number where the function is called from. useEvent, useThrottle, and World:queryChanged are all examples. Under the hood, the storage for these functions is kept around only as long as you keep calling them from the same call site (file and line number). If you cease calling a topologically-aware function in the same place every frame, then the storage that was created for them is automatically cleaned up. Generally, this is what you want. If you stop calling useEvent on a particular instance every frame - it's likely that you don't care about that instance anymore, so it makes sense for us to disconnect the event and delete any queued events that happened in the meantime. However, unintentionally triggering this clean up can lead to behavior you might not expect. For example, queryChangeduses topologically-aware storage to remember what entities have changed since your system last ran, in addition to what value your system last observed the component as having. Remember, when you call queryChanged for the first time (which is usually on the first frame of your game), it will iterate over all entities that match your query up front. This is done so that you don't miss any changes that occurred before your system was able to register its interest in the component you're querying over. But, if you stop calling queryChanged from the same place every frame, like if you have an early return at the top of your system, this storage is cleaned up. That means the next time your queryChanged does run, it will iterate over all matches that are currently in the world as if they are new components (because, as far as it can tell, they are). function mySystem() if useThrottle(1) then for id, health in world:queryChanged(Health) do -- Uh oh! Every time this runs, *every* health component will be looped over. -- The for loop runs only once per second, which means that on next frame where this code -- isn't reached, the storage for queryChanged is cleaned up. end end end  The solution to this problem is to ensure that your queryChanged for loops run unconditionally every time your system runs. (Unless you really do want this behavior!) "},{"title":"Replacing a component, then using the old one later​","type":1,"pageTitle":"Common Mistakes","url":"/matter/docs/Guides/CommonMistakes#replacing-a-component-then-using-the-old-one-later","content":"In Matter, components are immutable. They are frozen with table.freeze and you can't modify them. This is for two main reasons: It makes change detection easy and performant. Using queryChanged to get a list of changed components is able to exist and be fast because components are immutable. Since it is not possible to change the component tables, the only way for a component to change is if a new table is made and the user calls world:insert with it.A large class of bugs are rooted in values changing out from underneath you. When you pass tables around, oftentimes code is not written to expect their values to be able to change arbitrarily. This becomes problematic when more than one place in your code has an active reference to the same table. By using immutable tables for our components, we can address these concerns. However, the trade off is that it's now possible to make the other mistake: You could get a component from an entity, and call patch on it and insert it, like this: local health = world:get(id, Health) world:insert(id, health:patch({ current = health.current - 10 }))  ...and then attempt to use the health variable later: if health.current &lt; 0 then -- ... end  This is not correct! We just changed the Health component on this entity earlier in the function. health:patchdoes not modify the table that is stored in the health variable. Thus, the health table that we are using in the comparison in the latter code sample is the old value, not the new one we just changed! One way you can solve this problem is by reassigning health to the updated value before inserting it. local health = world:get(id, Health) health = health:patch({ current = health.current - 10 }) world:insert(id, health) if health.current &lt; 0 then -- ... end  "},{"title":"Why ECS","type":0,"sectionRef":"#","url":"/matter/docs/WhyECS","content":"Why ECS Behavior is declarative. Systems run every frame, and declare what the state of the world should be right now. This makes code self-healing and more resilient to game-breaking bugs than in an event-driven model where reacting to something happening only happens once.Game state and behavior are entirely decoupled and all game state is accessible to any system.Game state is structured and easy to reason about. We reconcile state into the data model so we have one source of truth.Systems are self-contained and adding new behaviors to your game is as simple as adding a new system that declares something about how the world should be.Reusing code is easy because an entity can have many different types of components. Existing systems can affect new types of entities, and new systems automatically affect all related entities.All system code runs contiguously and in a fixed order, every frame. Event-driven code can be sensitive to ordering, because doing anything can trigger an event that jumps into another code path, which in turn could do something else that triggers an event. With systems, your code always runs in the same, fixed order, which makes it much more predictable and resilient to new behaviors caused from refactors.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/matter/docs/Installation","content":"","keywords":""},{"title":"Wally package manager​","type":1,"pageTitle":"Installation","url":"/matter/docs/Installation#wally-package-manager","content":"Install Wally with Aftman. aftman.toml [tools] wally = &quot;upliftgames/wally@0.3.1&quot;  If you don't have a wally.toml file, run wally init.Add matter under [dependencies]. Copy the latest version from this page. wally.toml [package] name = &quot;biff/package&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] matter = &quot;evaera/matter@X.X.X&quot; # Don't copy this. This won't work. # Copy real string from page linked above.  Run wally install.Sync in the Packages folder with Rojo. "},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"/matter/docs/Installation#manual","content":"Download matter.rbxm from the latest release.Sync in with Rojo or import into Roblox Studio manually. "},{"title":"World","type":0,"sectionRef":"#","url":"/matter/api/World","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"World","url":"/matter/api/World#functions","content":" "},{"title":"new​","type":1,"pageTitle":"World","url":"/matter/api/World#new","content":"&lt;/&gt; World.new() → () Creates a new World.  "},{"title":"iterating over World​","type":1,"pageTitle":"World","url":"/matter/api/World#__iter","content":"&lt;/&gt; for number, {[Component]: ComponentInstance} in World do Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping Component to Component Instance. Usage: for entityId, entityData in world do print(entityId, entityData[Components.Example]) end   "},{"title":"spawn​","type":1,"pageTitle":"World","url":"/matter/api/World#spawn","content":"&lt;/&gt; World:spawn( ...: ComponentInstance-- The component values to spawn the entity with. ) → number-- The new entity ID. Spawns a new entity in the world with the given components.  "},{"title":"spawnAt​","type":1,"pageTitle":"World","url":"/matter/api/World#spawnAt","content":"&lt;/&gt; World:spawnAt( id: number,-- The entity ID to spawn with ...: ComponentInstance-- The component values to spawn the entity with. ) → number-- The same entity ID that was passed in Spawns a new entity in the world with a specific entity ID and given components. The next ID generated from World:spawn will be increased as needed to never collide with a manually specified ID.  "},{"title":"replace​","type":1,"pageTitle":"World","url":"/matter/api/World#replace","content":"&lt;/&gt; World:replace( id: number,-- The entity ID ...: ComponentInstance-- The component values to spawn the entity with. ) → () Replaces a given entity by ID with an entirely new set of components. Equivalent to removing all components from an entity, and then adding these ones.  "},{"title":"despawn​","type":1,"pageTitle":"World","url":"/matter/api/World#despawn","content":"&lt;/&gt; World:despawn( id: number-- The entity ID ) → () Despawns a given entity by ID, removing it and all its components from the world entirely.  "},{"title":"clear​","type":1,"pageTitle":"World","url":"/matter/api/World#clear","content":"&lt;/&gt; World:clear() → () Removes all entities from the world. caution Removing entities in this way is not reported by queryChanged.  "},{"title":"contains​","type":1,"pageTitle":"World","url":"/matter/api/World#contains","content":"&lt;/&gt; World:contains( id: number-- The entity ID ) → bool-- true if the entity exists Checks if the given entity ID is currently spawned in this world.  "},{"title":"get​","type":1,"pageTitle":"World","url":"/matter/api/World#get","content":"&lt;/&gt; World:get( id: number,-- The entity ID ...: Component-- The components to fetch ) → ...-- Returns the component values in the same order they were passed in Gets a specific component (or set of components) from a specific entity in this world.  "},{"title":"query​","type":1,"pageTitle":"World","url":"/matter/api/World#query","content":"&lt;/&gt; World:query( ...: Component-- The component types to query. Only entities with all of these components will be returned. ) → QueryResult-- See QueryResult docs. Performs a query against the entities in this World. Returns a QueryResult, which iterates over the results of the query. Order of iteration is not guaranteed. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end for id in world:query(Target):without(Model) do -- Again, with feeling end   "},{"title":"queryChanged​","type":1,"pageTitle":"World","url":"/matter/api/World#queryChanged","content":"&lt;/&gt; World:queryChanged( componentToTrack: Component,-- The component you want to listen to changes for. ...: nil ) → () → ( id, ChangeRecord )-- Iterator of entity ID and change record "},{"title":"Types","type":1,"pageTitle":"World","url":"/matter/api/World##","content":""},{"title":"​","type":1,"pageTitle":"World","url":"/matter/api/World#ChangeRecord","content":"interface ChangeRecord { new?: ComponentInstance-- The new value of the component. Nil if just removed. old?: ComponentInstance-- The former value of the component. Nil if just added. }   Topologically-aware function This function is only usable if called within the context of Loop:begin. Queries for components that have changed since the last time your system ran queryChanged. Only one changed record is returned per entity, even if the same entity changed multiple times. The order in which changed records are returned is not guaranteed to be the order that the changes occurred in. It should be noted that queryChanged does not have the same iterator invalidation concerns as World:query. tip The first time your system runs (i.e., on the first frame), all existing entities in the world that match your query are returned as &quot;new&quot; change records. info Calling this function from your system creates storage internally for your system. Then, changes meeting your criteria are pushed into your storage. Calling queryChanged again each frame drains this storage. If your system isn't called every frame, the storage will continually fill up and does not empty unless you drain it. If you stop calling queryChanged in your system, changes will stop being tracked. Returns queryChanged returns an iterator function, so you call it in a for loop just like World:query. The iterator returns the entity ID, followed by a ChangeRecord. The ChangeRecord type is a table that contains two fields, new and old, respectively containing the new component instance, and the old component instance. new and old will never be the same value. new will be nil if the component was removed (or the entity was despawned), and old will be nil if the component was just added. The old field will be the value of the component the last time this system observed it, not necessarily the value it changed from most recently. The ChangeRecord table is potentially shared with multiple systems tracking changes for this component, so it cannot be modified. for id, record in world:queryChanged(Model) do if record.new == nil then -- Model was removed if enemy.type == &quot;this is a made up example&quot; then world:remove(id, Enemy) end end end   "},{"title":"insert​","type":1,"pageTitle":"World","url":"/matter/api/World#insert","content":"&lt;/&gt; World:insert( id: number,-- The entity ID ...: ComponentInstance-- The component values to insert ) → () Inserts a component (or set of components) into an existing entity. If another instance of a given component already exists on this entity, it is replaced. world:insert( entityId, ComponentA({ foo = &quot;bar&quot; }), ComponentB({ baz = &quot;qux&quot; }) )   "},{"title":"remove​","type":1,"pageTitle":"World","url":"/matter/api/World#remove","content":"&lt;/&gt; World:remove( id: number,-- The entity ID ...: Component-- The components to remove ) → ...ComponentInstance-- Returns the component instance values that were removed in the order they were passed. Removes a component (or set of components) from an existing entity. local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)   "},{"title":"size​","type":1,"pageTitle":"World","url":"/matter/api/World#size","content":"&lt;/&gt; World:size() → () Returns the number of entities currently spawned in the world.  "},{"title":"optimizeQueries​","type":1,"pageTitle":"World","url":"/matter/api/World#optimizeQueries","content":"&lt;/&gt; World:optimizeQueries() → ()  tip Loop automatically calls this function on your World(s), so there is no need to call it yourself if you're using a Loop. If you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize the internal storage for queries. This is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query fromWorld:query. While inside a query, any changes to the World are stored in a separate location from the rest of the World. Calling this function combines the separate storage back into the main storage, which speeds things up again. "},{"title":"Matter","type":0,"sectionRef":"#","url":"/matter/api/Matter","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#types","content":" "},{"title":"ConnectionObject​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#ConnectionObject","content":"&lt;/&gt; type ConnectionObject = { Disconnect: (() → ())?, Destroy: (()-&gt;())?, disconnect: (() → ())?, destroy: (() → ())? } | () → () A connection object returned by a custom event must be either a table with any of the following methods, or a cleanup function.  "},{"title":"CustomEvent​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#CustomEvent","content":"&lt;/&gt; interface CustomEvent { Connect: ((...) → ConnectionObject)? on: ((...) → ConnectionObject)? connect: ((...) → ConnectionObject)? } A custom event must have any of these 3 methods. "},{"title":"Properties​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#properties","content":" "},{"title":"World​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#World","content":"&lt;/&gt; Matter.World: World   "},{"title":"Loop​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#Loop","content":"&lt;/&gt; Matter.Loop: Loop   "},{"title":"Debugger​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#Debugger","content":"&lt;/&gt; Matter.Debugger: Debugger   "},{"title":"None​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#None","content":"&lt;/&gt; Matter.None: None A value should be interpreted as nil when merging dictionaries. Matter.None is used by Component:patch. "},{"title":"Functions​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#functions","content":" "},{"title":"useHookState​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#useHookState","content":"&lt;/&gt; Matter.useHookState( discriminator?: any,-- A unique value to additionally key by cleanupCallback: (storage: {}) → boolean?-- A function to run when the storage for this hook is cleaned up ) → {}  tip Don't use this function directly in your systems. This function is used for implementing your own topologically-aware functions. It should not be used in your systems directly. You should use this function to implement your own utilities, similar to useEvent and useThrottle. useHookState does one thing: it returns a table. An empty, pristine table. Here's the cool thing though: it always returns the same table, based on the script and line where your function (the function calling useHookState) was called. Uniqueness If your function is called multiple times from the same line, perhaps within a loop, the default behavior ofuseHookState is to uniquely identify these by call count, and will return a unique table for each call. However, you can override this behavior: you can choose to key by any other value. This means that in addition to script and line number, the storage will also only return the same table if the unique value (otherwise known as the &quot;discriminator&quot;) is the same. Cleaning up As a second optional parameter, you can pass a function that is automatically invoked when your storage is about to be cleaned up. This happens when your function (and by extension, useHookState) ceases to be called again next frame (keyed by script, line number, and discriminator). Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work, like disconnecting events. Or, you could return true, and abort cleaning up altogether. If you abort cleanup, your storage will stick around another frame (even if your function wasn't called again). This can be used when you know that the user will (or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for a number of seconds). If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup, or the user actually calls your function again. Example: useThrottle This is the entire implementation of the built-in useThrottle function: local function cleanup(storage) return os.clock() &lt; storage.expiry end local function useThrottle(seconds, discriminator) local storage = useHookState(discriminator, cleanup) if storage.time == nil or os.clock() - storage.time &gt;= seconds then storage.time = os.clock() storage.expiry = os.clock() + seconds return true end return false end A lot of talk for something so simple, right?  "},{"title":"component​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#component","content":"&lt;/&gt; Matter.component( name?: string,-- Optional name for debugging purposes defaultData?: {}-- Default data that will be merged with data passed to the component when created ) → Component-- Your new type of component Creates a new type of component. Call the component as a function to create an instance of that component. If defaultData is specified, it will be merged with data passed to the component when the component instance is created. Note that this is not fallback data: if you later remove a field from a component instance that is specified in the default data, it won't fall back to the value specified in default data. -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; })   "},{"title":"useThrottle​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#useThrottle","content":"&lt;/&gt; Matter.useThrottle( seconds: number,-- The number of seconds to throttle for discriminator?: any-- A unique value to additionally key by ) → boolean-- returns true every x seconds, otherwise false  Topologically-aware function This function is only usable if called within the context of Loop:begin. Utility for easy time-based throttling. Accepts a duration, and returns true if it has been that long since the last time this function returned true. Always returns true the first time. This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can throttle doing something to each entity individually. if useThrottle(1) then -- Keyed by script and line number only print(&quot;only prints every second&quot;) end for id, enemy in world:query(Enemy) do if useThrottle(5, id) then -- Keyed by script, line number, and the entity id print(&quot;Recalculate target...&quot;) end end   "},{"title":"log​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#log","content":"&lt;/&gt; Matter.log(...: any) → ()  Topologically-aware function This function is only usable if called within the context of Loop:begin. Logs some text. Readable in the Matter debugger.  "},{"title":"useEvent​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#useEvent","content":"&lt;/&gt; Matter.useEvent( instance: Instance | {[string]: CustomEvent} | CustomEvent,-- The instance or the custom event, or a table that has the event you want to connect to event: string | RBXScriptSignal | CustomEvent-- The name of, or the actual event that you want to connect to ) → () → ( number, ...any )  Topologically-aware function This function is only usable if called within the context of Loop:begin. Collects events that fire during the frame and allows iteration over event arguments. for _, player in ipairs(Players:GetPlayers()) do for i, character in useEvent(player, &quot;CharacterAdded&quot;) do world:spawn( Components.Target(), Components.Model({ model = character, }) ) end end Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments from the specified event. Events are returned in the order that they were fired. caution useEvent keys storage uniquely identified by the script and line number useEvent was called from, and the first parameter (instance). If the second parameter, event, is not equal to the event passed in for this unique storage last frame, the old event is disconnected from and the new one is connected in its place. Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with a variable. Dynamically changing the first parameter (instance) is fine. for _, instance in pairs(someTable) do for i, arg1, arg2 in useEvent(instance, &quot;Touched&quot;) do -- This is ok end end for _, instance in pairs(someTable) do local event = getEventSomehow() for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK end end If useEvent ceases to be called on the same line with the same instance and event, the event connection is disconnected from automatically. You can also pass the actual event object instead of its name as the second parameter: useEvent(instance, instance.Touched) useEvent(instance, instance:GetPropertyChangedSignal(&quot;Name&quot;)) useEvent supports custom events as well, so you can pass in an object with a Connect, connect or an on method. The object returned by any event must either be a cleanup function, or a table with a Disconnect or a Destroy method so that useEvent can later clean the event up when needed. See ConnectionObject for more information.  "},{"title":"useDeltaTime​","type":1,"pageTitle":"Matter","url":"/matter/api/Matter#useDeltaTime","content":"&lt;/&gt; Matter.useDeltaTime() → number  Topologically-aware function This function is only usable if called within the context of Loop:begin. Returns the os.clock() time delta between the start of this and last frame. "},{"title":"Matter Debugger","type":0,"sectionRef":"#","url":"/matter/docs/Guides/MatterDebugger","content":"","keywords":""},{"title":"Adding the Matter debugger to your game​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#adding-the-matter-debugger-to-your-game","content":""},{"title":"Installing Plasma​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#installing-plasma","content":"You need to install Plasma as a dependency to your project. We recommend you do this with Wally, the Roblox open source package manager. wally.toml [dependencies] plasma = &quot;evaera/plasma@0.4.2&quot;  "},{"title":"Create the debugger​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#create-the-debugger","content":"Create the debugger where you create your Loop and World: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Packages = ReplicatedStorage.Packages local Matter = require(Packages.matter) local Plasma = require(Packages.plasma) local debugger = Matter.Debugger.new(Plasma) -- Pass Plasma into the debugger! local widgets = debugger:getWidgets() local loop = Matter.Loop.new(world, state, widgets) -- Pass the widgets to all your systems!  Call debugger:autoInitialize(loop) to automatically set up the Loop middleware necessary to invoke the debugger every frame: debugger:autoInitialize(loop)  Finally, we need a way to open the debugger You might want to only allow certain players to open the debugger, but that's up to you! UserInputService.InputBegan:Connect(function(input) if input.KeyCode == Enum.KeyCode.F4 then debugger:toggle() end end)  "},{"title":"Authorization​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#authorization","content":"By default, the server-side debugger only works in Studio. To allow players to connect to the server-side debugger in live games, you need to specify an authorize function: debugger.authorize = function(player) if player:GetRankInGroup(372) &gt; 250 then -- example return true end end  "},{"title":"Entity Highlight​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#entity-highlight","content":""},{"title":"Highlight selected entity​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#highlight-selected-entity","content":"To highlight the selected entity in the World inspector, create the findInstanceFromEntity function in the debugger. debugger.findInstanceFromEntity = function(id) if not world:contains(id) then return end local model = world:get(id, components.Model) return model and model.model or nil end  Change the above function so that it works with your game's component structure. "},{"title":"Hover selection​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#hover-selection","content":"Create attributes clientEntityId and serverEntityId on instances to enable in-world hover selection when you hold the ALT key. Click to select the entity.  This can be done by creating a system like this on both the client and the server. local name = RunService:IsServer() and &quot;serverEntityId&quot; or &quot;clientEntityId&quot; local function updateModelAttribute(world) for id, record in world:queryChanged(Components.Model) do if record.new then record.new.model:SetAttribute(name, id) end end end  Change the above function so that it works with your game's component structure. "},{"title":"Available widgets​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#available-widgets","content":"The following Plasma widgets are available: arrow (3D Arrow gizmo for debugging Vector math)blur (blurs the camera background)buttoncheckboxheadinglabelportal (Insert instances into somewhere other than the provided frame)row (lay elements out horizontally)sliderspace (empty space)spinner (loading spinner)tablewindow For details on these widgets, check out the Plasma docs "},{"title":"Demo videos​","type":1,"pageTitle":"Matter Debugger","url":"/matter/docs/Guides/MatterDebugger#demo-videos","content":"Demo of hot reloading and the Matter debugger Demo of the server-side debugger Note: When multiple players connect to the server-side debugger, their views are linked. There is only one instance of the server debugger (because creating UI elements within the server systems means the UI is owned by the server). Multiple players can connect to and share the server debugger. "},{"title":"Replication","type":0,"sectionRef":"#","url":"/matter/docs/Guides/Replication","content":"","keywords":""},{"title":"Deciding which components to replicate​","type":1,"pageTitle":"Replication","url":"/matter/docs/Guides/Replication#deciding-which-components-to-replicate","content":"You need to decide which components are replicated and which are not. You probably don't want to replicate every component, because some components might have data that's only relevant to the server or data that is updated too frequently to comfortably replicate each time it changes. In this example, we'll just define a list of component names we want to replicate. local REPLICATED_COMPONENTS = { &quot;Roomba&quot;, &quot;Model&quot;, &quot;Health&quot;, &quot;Target&quot;, &quot;Mothership&quot;, &quot;Spinner&quot;, }  "},{"title":"Creating the replication system​","type":1,"pageTitle":"Replication","url":"/matter/docs/Guides/Replication#creating-the-replication-system","content":"Create a new system called replication on the server. Put the list of replicated components at the top of the file. We'll create a remote event while we're at it: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RemoteEvent = Instance.new(&quot;RemoteEvent&quot;) RemoteEvent.Name = &quot;MatterRemote&quot; RemoteEvent.Parent = ReplicatedStorage  Let's convert the list of component names into actual components. This is assuming you have a Components module that exports your components, like the matter example game does. local replicatedComponents = {} for _, name in REPLICATED_COMPONENTS do replicatedComponents[Components[name]] = true end  Let's create an empty function for our system and set up the rest of the system before we really get going. local function replication(world) -- todo! end return { system = replication, priority = math.huge, }  We set the system priority to infinity so that it always runs last, at the end of the frame. "},{"title":"Replicating changes to the clients​","type":1,"pageTitle":"Replication","url":"/matter/docs/Guides/Replication#replicating-changes-to-the-clients","content":"We can use World:queryChanged to detect when a component changes and replicate it to all players in the game. -- In the replication function we created above. -- Create a table to buffer up our changes so we only send out at most one remote event per frame local changes = {} -- Loop over our table of replicated components for component in replicatedComponents do -- Loop over queryChanged for this component for entityId, record in world:queryChanged(component) do -- We convert the entity ID to a string because tables sent over remote events in Roblox -- can only have string keys. (did I just teach you something new?) local key = tostring(entityId) -- Get the name of the component. This is done with tostring as well because components have -- a custom __tostring metamethod that returns their human-readable name. local name = tostring(component) -- If there aren't any changes from this entity in the buffer so far, create the table for it if changes[key] == nil then changes[key] = {} end -- Only send over the changed component if the entity still exists in our world. if world:contains(entityId) then -- Lua tables can't contain nil as values, this is indistinguishable from the key just -- not existing at all. -- Instead, we set all values to a table, and then create a key inside that for the real -- value. This lets us detect when a component is removed (set to nil) changes[key][name] = { data = record.new } end end -- Check if there are any changes in our buffer before sending the changes to all clients. if next(changes) then RemoteEvent:FireAllClients(changes) end end  This works pretty well! Only one problem. What if a player joins late when the world is already created? "},{"title":"Replicating the existing world to new players​","type":1,"pageTitle":"Replication","url":"/matter/docs/Guides/Replication#replicating-the-existing-world-to-new-players","content":"We can augment the system we created above with some special code to handle sending the entire World to new players who join the game late. -- Also inside our replication function -- Run some code every time a player joins for _, player in useEvent(Players, &quot;PlayerAdded&quot;) do local payload = {} -- Loop over the entire World using the world's __iter metamethod implementation for entityId, entityData in world do local entityPayload = {} -- Loop over all the components the entity has for component, componentData in entityData do -- Only if it's in our list of replicated components... if replicatedComponents[component] then -- Add it to the data we're sending for this entity entityPayload[tostring(component)] = { data = componentData } end end -- Add the entity data to our overall payload payload[tostring(entityId)] = entityPayload end RemoteEvent:FireClient(player, payload) end  The payload object is structured the exact same way as our changes object from earlier, so we only need to write one piece of code on the client to handle both of these cases. "},{"title":"Receiving replication on the client​","type":1,"pageTitle":"Replication","url":"/matter/docs/Guides/Replication#receiving-replication-on-the-client","content":"The code on the client is not a system in our ECS, since it's just attaching an event listener to a Remote Event. We can put this code in the same file where we create our World, so we have a reference to it already. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Components = require(ReplicatedStorage.Game.components) -- example -- Get our remote event that we created on the server local RemoteEvent = ReplicatedStorage:WaitForChild(&quot;MatterRemote&quot;) -- A lookup table from server entity IDs to client entity IDs. They're different! local entityIdMap = {} RemoteEvent.OnClientEvent:Connect(function(entities) -- entities is the data sent from the server. Either the `payload` or `changes` from earlier! -- Loop over the entities the server is replicating for serverEntityId, componentMap in entities do -- Check if we've created this entity on the client before local clientEntityId = entityIdMap[serverEntityId] -- If we've created this entity before, and there are no components inside its list, that means -- the entity was despawned on the server. We despawn it here too. if clientEntityId and next(componentMap) == nil then world:despawn(clientEntityId) -- Remove it from our lookup table entityIdMap[serverEntityId] = nil continue end local componentsToInsert = {} local componentsToRemove = {} -- Loop over all the components in the entity for name, container in componentMap do -- If container.data exists, the component was either changed or added. if container.data then table.insert(componentsToInsert, Components[name](container.data)) else -- if it doesn't exist, it was removed! table.insert(componentsToRemove, Components[name]) end end -- We haven't created this entity on the client before. create it. if clientEntityId == nil then clientEntityId = world:spawn(unpack(componentsToInsert)) -- add the client-side entity id to our lookup table entityIdMap[serverEntityId] = clientEntityId else -- we've seen this entity before. -- Just insert or remove any necessary components. if #componentsToInsert &gt; 0 then world:insert(clientEntityId, unpack(componentsToInsert)) end if #componentsToRemove &gt; 0 then world:remove(clientEntityId, unpack(componentsToRemove)) end end end end)  And that's all there is to it! You could make this system more advanced in a lot of different ways, but this should get you started with a basic replication system for your game. "}]